## Problems

1. Majority Element: Use a counter
2. Remove Duplicates From Sorted Array: Two pointers, assignment on original array directly
3. Merge Sorted Array: Reversed merge, will save time and space
4. Min Stack: Use an extra stack to store min elements, if a new element is larger than the current minimum, we do not need to push it on to the min stack. When we perform the pop operation, check if the popped element is the same as the current minimum. If it is, pop it off the min stack too
5. Rotate Array: BA = rotate(rotate(A)rotate(B))
6. Unique Binary Search Trees: DP, F(i, n) = G(i - 1) * G(n - i), F(i, n) means number of unique trees when i is root, G(n) means total number of unique trees when nodes number is n, so G(n) = G(0) * G(n - 1) + G(1) * G(n - 2) + ... + G(n - 1) * G(0)
7. Maximum Subarray: maxSubArray(A, i) = maxSubArray(A, i - 1) > 0 ? maxSubArray(A, i - 1) : 0 + A[i];


## Algorithms

### Containing a sequence

1. Rabin-Karp(or Karp-Rabin): Uses hashing to search pattern string in a text. For text of length n and p patterns of combined length m, its average and best case running time is O(n+m) in space O(p), but its worst-case time is O(nm). Because of common part of string, so hashing of a string only need to substraction and addition operation, which will be constant time.
2. Knuth-Morris-Pratt(or KMP): Search for occurrences of a word within a main text string by employing the observation that when a mismatch occurs, the word itself embodies sufficient information to determine where the next match could begin, thus bypassing re-examination of previously matched characters. Using Partial Match Table to predict movation.
3. Boyer-Moore: String searching algorithm. Bad characters and good postfixes movation.
