!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
NODE_H_	.\node.h	2;"	d
Node	.\node.h	/^  Node();$/;"	p	class:Node	access:public	signature:()
Node	.\node.h	/^  Node(const Node<Type>& node);$/;"	p	class:Node	access:public	signature:(const Node<Type>& node)
Node	.\node.h	/^  Node(const Type& val);$/;"	p	class:Node	access:public	signature:(const Type& val)
Node	.\node.h	/^Node<Type>::Node()$/;"	f	class:Node	signature:()
Node	.\node.h	/^Node<Type>::Node(const Node<Type>& node)$/;"	f	class:Node	signature:(const Node<Type>& node)
Node	.\node.h	/^Node<Type>::Node(const Type& val)$/;"	f	class:Node	signature:(const Type& val)
Node	.\node.h	/^class Node$/;"	c
Node::Node	.\node.h	/^  Node();$/;"	p	class:Node	access:public	signature:()
Node::Node	.\node.h	/^  Node(const Node<Type>& node);$/;"	p	class:Node	access:public	signature:(const Node<Type>& node)
Node::Node	.\node.h	/^  Node(const Type& val);$/;"	p	class:Node	access:public	signature:(const Type& val)
Node::Node	.\node.h	/^Node<Type>::Node()$/;"	f	class:Node	signature:()
Node::Node	.\node.h	/^Node<Type>::Node(const Node<Type>& node)$/;"	f	class:Node	signature:(const Node<Type>& node)
Node::Node	.\node.h	/^Node<Type>::Node(const Type& val)$/;"	f	class:Node	signature:(const Type& val)
Node::copyNode	.\tree.h	/^void Node<Type>::copyNode(Node<Type>* destNode, const Node<Type>* srcNode)$/;"	f	class:Node	signature:(Node<Type>* destNode, const Node<Type>* srcNode)
Node::left	.\node.h	/^  Node<Type>* left;$/;"	m	class:Node	access:private
Node::operator =	.\node.h	/^  Node<Type>& operator=(const Node<Type>& node);$/;"	p	class:Node	access:public	signature:(const Node<Type>& node)
Node::operator =	.\node.h	/^Node<Type>& Node<Type>::operator=(const Node<Type>& node)$/;"	f	class:Node	signature:(const Node<Type>& node)
Node::right	.\node.h	/^  Node<Type>* right;$/;"	m	class:Node	access:private
Node::value	.\node.h	/^  Type value;$/;"	m	class:Node	access:private
Node::~Node	.\node.h	/^  virtual ~Node();$/;"	p	class:Node	access:public	signature:()
Node::~Node	.\node.h	/^Node<Type>::~Node()$/;"	f	class:Node	signature:()
TREE_H_	.\tree.h	2;"	d
Tree	.\tree.h	/^  Tree();$/;"	p	class:Tree	access:public	signature:()
Tree	.\tree.h	/^  Tree(const Tree<Type>& tree);$/;"	p	class:Tree	access:public	signature:(const Tree<Type>& tree)
Tree	.\tree.h	/^Tree<Type>::Tree()$/;"	f	class:Tree	signature:()
Tree	.\tree.h	/^Tree<Type>::Tree(const Tree<Type>& tree)$/;"	f	class:Tree	signature:(const Tree<Type>& tree)
Tree	.\tree.h	/^class Tree$/;"	c
Tree::Tree	.\tree.h	/^  Tree();$/;"	p	class:Tree	access:public	signature:()
Tree::Tree	.\tree.h	/^  Tree(const Tree<Type>& tree);$/;"	p	class:Tree	access:public	signature:(const Tree<Type>& tree)
Tree::Tree	.\tree.h	/^Tree<Type>::Tree()$/;"	f	class:Tree	signature:()
Tree::Tree	.\tree.h	/^Tree<Type>::Tree(const Tree<Type>& tree)$/;"	f	class:Tree	signature:(const Tree<Type>& tree)
Tree::copyNode	.\tree.h	/^  void copyNode(Node<Type>* destNode, const Node<Type>* srcNode);$/;"	p	class:Tree	access:private	signature:(Node<Type>* destNode, const Node<Type>* srcNode)
Tree::del	.\tree.h	/^  void del(const Type& val);$/;"	p	class:Tree	access:public	signature:(const Type& val)
Tree::del	.\tree.h	/^void Tree<Type>::del(const Type& val)$/;"	f	class:Tree	signature:(const Type& val)
Tree::delNode	.\tree.h	/^  Node<Type>* delNode(Node<Type>* node);$/;"	p	class:Tree	access:private	signature:(Node<Type>* node)
Tree::delNode	.\tree.h	/^Node<Type>* Tree<Type>::delNode(Node<Type>* node, const Type& val)$/;"	f	class:Tree	signature:(Node<Type>* node, const Type& val)
Tree::empty	.\tree.h	/^  bool empty();$/;"	p	class:Tree	access:public	signature:()
Tree::empty	.\tree.h	/^bool Tree<Type>::empty()$/;"	f	class:Tree	signature:()
Tree::find	.\tree.h	/^  bool find(const Type& val);$/;"	p	class:Tree	access:public	signature:(const Type& val)
Tree::find	.\tree.h	/^bool Tree<Type>::find(const Type& val)$/;"	f	class:Tree	signature:(const Type& val)
Tree::findMin	.\tree.h	/^  Node<Type>* findMin(Node<Type>* node, const Type& val);$/;"	p	class:Tree	access:private	signature:(Node<Type>* node, const Type& val)
Tree::findMin	.\tree.h	/^Node<Type>* Tree<Type>::findMin(Node<Type>* node)$/;"	f	class:Tree	signature:(Node<Type>* node)
Tree::findNode	.\tree.h	/^  Node<Type>* findNode(Node<Type>* node, const Type& val);$/;"	p	class:Tree	access:private	signature:(Node<Type>* node, const Type& val)
Tree::findNode	.\tree.h	/^Node<Type>* Tree<Type>::findNode(Node<Type>* node, const Type& val)$/;"	f	class:Tree	signature:(Node<Type>* node, const Type& val)
Tree::freeNode	.\tree.h	/^  void freeNode(Node<Type>* node);$/;"	p	class:Tree	access:private	signature:(Node<Type>* node)
Tree::freeNode	.\tree.h	/^void Tree<Type>::freeNode(Node<Type>* node)$/;"	f	class:Tree	signature:(Node<Type>* node)
Tree::inOrder	.\tree.h	/^  void inOrder(Node<Type>* node);$/;"	p	class:Tree	access:private	signature:(Node<Type>* node)
Tree::inOrder	.\tree.h	/^void Tree<Type>::inOrder(Node<Type>* node)$/;"	f	class:Tree	signature:(Node<Type>* node)
Tree::inOrderTraversal	.\tree.h	/^  void inOrderTraversal();$/;"	p	class:Tree	access:public	signature:()
Tree::inOrderTraversal	.\tree.h	/^void Tree<Type>::inOrderTraversal()$/;"	f	class:Tree	signature:()
Tree::insert	.\tree.h	/^  void insert(const Type& val);$/;"	p	class:Tree	access:public	signature:(const Type& val)
Tree::insert	.\tree.h	/^void Tree<Type>::insert(const Type& val)$/;"	f	class:Tree	signature:(const Type& val)
Tree::insertNode	.\tree.h	/^  Node<Type>* insertNode(Node<Type>* node, const Type& val);$/;"	p	class:Tree	access:private	signature:(Node<Type>* node, const Type& val)
Tree::insertNode	.\tree.h	/^Node<Type>* Tree<Type>::insertNode(Node<Type>* node, const Type& val)$/;"	f	class:Tree	signature:(Node<Type>* node, const Type& val)
Tree::operator =	.\tree.h	/^  Tree<Type>& operator=(const Tree<Type>& tree);$/;"	p	class:Tree	access:public	signature:(const Tree<Type>& tree)
Tree::operator =	.\tree.h	/^Tree<Type>& Tree<Type>::operator=(const Tree<Type>& tree)$/;"	f	class:Tree	signature:(const Tree<Type>& tree)
Tree::postOrder	.\tree.h	/^  void postOrder(Node<Type>* node);$/;"	p	class:Tree	access:private	signature:(Node<Type>* node)
Tree::postOrder	.\tree.h	/^void Tree<Type>::postOrder(Node<Type>* node)$/;"	f	class:Tree	signature:(Node<Type>* node)
Tree::postOrderTraversal	.\tree.h	/^  void postOrderTraversal();$/;"	p	class:Tree	access:public	signature:()
Tree::postOrderTraversal	.\tree.h	/^void Tree<Type>::postOrderTraversal()$/;"	f	class:Tree	signature:()
Tree::preOrder	.\tree.h	/^  void preOrder(Node<Type>* node);$/;"	p	class:Tree	access:private	signature:(Node<Type>* node)
Tree::preOrder	.\tree.h	/^void Tree<Type>::preOrder(Node<Type>* node)$/;"	f	class:Tree	signature:(Node<Type>* node)
Tree::preOrderTraversal	.\tree.h	/^  void preOrderTraversal();$/;"	p	class:Tree	access:public	signature:()
Tree::preOrderTraversal	.\tree.h	/^void Tree<Type>::preOrderTraversal()$/;"	f	class:Tree	signature:()
Tree::root	.\tree.h	/^  Node<Type>* root;$/;"	m	class:Tree	access:private
Tree::~Tree	.\tree.h	/^  virtual ~Tree();$/;"	p	class:Tree	access:public	signature:()
Tree::~Tree	.\tree.h	/^Tree<Type>::~Tree()$/;"	f	class:Tree	signature:()
copyNode	.\tree.h	/^  void copyNode(Node<Type>* destNode, const Node<Type>* srcNode);$/;"	p	class:Tree	access:private	signature:(Node<Type>* destNode, const Node<Type>* srcNode)
copyNode	.\tree.h	/^void Node<Type>::copyNode(Node<Type>* destNode, const Node<Type>* srcNode)$/;"	f	class:Node	signature:(Node<Type>* destNode, const Node<Type>* srcNode)
del	.\tree.h	/^  void del(const Type& val);$/;"	p	class:Tree	access:public	signature:(const Type& val)
del	.\tree.h	/^void Tree<Type>::del(const Type& val)$/;"	f	class:Tree	signature:(const Type& val)
delNode	.\tree.h	/^  Node<Type>* delNode(Node<Type>* node);$/;"	p	class:Tree	access:private	signature:(Node<Type>* node)
delNode	.\tree.h	/^Node<Type>* Tree<Type>::delNode(Node<Type>* node, const Type& val)$/;"	f	class:Tree	signature:(Node<Type>* node, const Type& val)
empty	.\tree.h	/^  bool empty();$/;"	p	class:Tree	access:public	signature:()
empty	.\tree.h	/^bool Tree<Type>::empty()$/;"	f	class:Tree	signature:()
find	.\tree.h	/^  bool find(const Type& val);$/;"	p	class:Tree	access:public	signature:(const Type& val)
find	.\tree.h	/^bool Tree<Type>::find(const Type& val)$/;"	f	class:Tree	signature:(const Type& val)
findMin	.\tree.h	/^  Node<Type>* findMin(Node<Type>* node, const Type& val);$/;"	p	class:Tree	access:private	signature:(Node<Type>* node, const Type& val)
findMin	.\tree.h	/^Node<Type>* Tree<Type>::findMin(Node<Type>* node)$/;"	f	class:Tree	signature:(Node<Type>* node)
findNode	.\tree.h	/^  Node<Type>* findNode(Node<Type>* node, const Type& val);$/;"	p	class:Tree	access:private	signature:(Node<Type>* node, const Type& val)
findNode	.\tree.h	/^Node<Type>* Tree<Type>::findNode(Node<Type>* node, const Type& val)$/;"	f	class:Tree	signature:(Node<Type>* node, const Type& val)
freeNode	.\tree.h	/^  void freeNode(Node<Type>* node);$/;"	p	class:Tree	access:private	signature:(Node<Type>* node)
freeNode	.\tree.h	/^void Tree<Type>::freeNode(Node<Type>* node)$/;"	f	class:Tree	signature:(Node<Type>* node)
inOrder	.\tree.h	/^  void inOrder(Node<Type>* node);$/;"	p	class:Tree	access:private	signature:(Node<Type>* node)
inOrder	.\tree.h	/^void Tree<Type>::inOrder(Node<Type>* node)$/;"	f	class:Tree	signature:(Node<Type>* node)
inOrderTraversal	.\tree.h	/^  void inOrderTraversal();$/;"	p	class:Tree	access:public	signature:()
inOrderTraversal	.\tree.h	/^void Tree<Type>::inOrderTraversal()$/;"	f	class:Tree	signature:()
insert	.\tree.h	/^  void insert(const Type& val);$/;"	p	class:Tree	access:public	signature:(const Type& val)
insert	.\tree.h	/^void Tree<Type>::insert(const Type& val)$/;"	f	class:Tree	signature:(const Type& val)
insertNode	.\tree.h	/^  Node<Type>* insertNode(Node<Type>* node, const Type& val);$/;"	p	class:Tree	access:private	signature:(Node<Type>* node, const Type& val)
insertNode	.\tree.h	/^Node<Type>* Tree<Type>::insertNode(Node<Type>* node, const Type& val)$/;"	f	class:Tree	signature:(Node<Type>* node, const Type& val)
left	.\node.h	/^  Node<Type>* left;$/;"	m	class:Node	access:private
main	.\test.cc	/^int main()$/;"	f	signature:()
operator =	.\node.h	/^  Node<Type>& operator=(const Node<Type>& node);$/;"	p	class:Node	access:public	signature:(const Node<Type>& node)
operator =	.\node.h	/^Node<Type>& Node<Type>::operator=(const Node<Type>& node)$/;"	f	class:Node	signature:(const Node<Type>& node)
operator =	.\tree.h	/^  Tree<Type>& operator=(const Tree<Type>& tree);$/;"	p	class:Tree	access:public	signature:(const Tree<Type>& tree)
operator =	.\tree.h	/^Tree<Type>& Tree<Type>::operator=(const Tree<Type>& tree)$/;"	f	class:Tree	signature:(const Tree<Type>& tree)
postOrder	.\tree.h	/^  void postOrder(Node<Type>* node);$/;"	p	class:Tree	access:private	signature:(Node<Type>* node)
postOrder	.\tree.h	/^void Tree<Type>::postOrder(Node<Type>* node)$/;"	f	class:Tree	signature:(Node<Type>* node)
postOrderTraversal	.\tree.h	/^  void postOrderTraversal();$/;"	p	class:Tree	access:public	signature:()
postOrderTraversal	.\tree.h	/^void Tree<Type>::postOrderTraversal()$/;"	f	class:Tree	signature:()
preOrder	.\tree.h	/^  void preOrder(Node<Type>* node);$/;"	p	class:Tree	access:private	signature:(Node<Type>* node)
preOrder	.\tree.h	/^void Tree<Type>::preOrder(Node<Type>* node)$/;"	f	class:Tree	signature:(Node<Type>* node)
preOrderTraversal	.\tree.h	/^  void preOrderTraversal();$/;"	p	class:Tree	access:public	signature:()
preOrderTraversal	.\tree.h	/^void Tree<Type>::preOrderTraversal()$/;"	f	class:Tree	signature:()
right	.\node.h	/^  Node<Type>* right;$/;"	m	class:Node	access:private
root	.\tree.h	/^  Node<Type>* root;$/;"	m	class:Tree	access:private
value	.\node.h	/^  Type value;$/;"	m	class:Node	access:private
~Node	.\node.h	/^  virtual ~Node();$/;"	p	class:Node	access:public	signature:()
~Node	.\node.h	/^Node<Type>::~Node()$/;"	f	class:Node	signature:()
~Tree	.\tree.h	/^  virtual ~Tree();$/;"	p	class:Tree	access:public	signature:()
~Tree	.\tree.h	/^Tree<Type>::~Tree()$/;"	f	class:Tree	signature:()
